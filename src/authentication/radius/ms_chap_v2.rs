//! 'Microsoft EAP CHAP Extensions v2'-related staff
//! https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02


use std::fmt::{Display, Formatter};
use std::str::EncodeUtf16;
use bytes::{Buf, Bytes};
use crypto::sha1::Sha1;
use crate::authentication::radius::eap;
use crate::utils;


type OpCode = u8;
// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2
const OP_CODE_CHALLENGE: OpCode = 1;
const OP_CODE_RESPONSE: OpCode = 2;
const OP_CODE_SUCCESS: OpCode = 3;
// const OP_CODE_FAILURE: OpCode = 4;
// const OP_CODE_CHANGE_PASSWORD: OpCode = 5;

const OP_CODE_SIZE: usize = 1;
const MS_CHAP_V2_ID_SIZE: usize = 1;
const MS_LENGTH_SIZE: usize = 2;
const VALUE_SIZE_SIZE: usize = 1;
// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.1
const CHALLENGE_SIZE: usize = 16;
// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.2
const RESPONSE_RESERVED_SIZE: usize = 8;
const RESPONSE_NT_RESPONSE_SIZE: usize = 24;
const RESPONSE_FLAGS_SIZE: usize = 1;
const RESPONSE_VALUE_SIZE: usize = CHALLENGE_SIZE + RESPONSE_RESERVED_SIZE
    + RESPONSE_NT_RESPONSE_SIZE + RESPONSE_FLAGS_SIZE;
const CHALLENGE_HASH_SIZE: usize = 8;
const PASSWORD_HASH_SIZE: usize = 16;
// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.3
const SUCCESS_REQUEST_AUTH_STRING_PREFIX: &str = "S=";
const SUCCESS_REQUEST_AUTH_STRING_SIZE: usize = 40;

/// A minimal message contains the `OpCode` only. See Success/Failure Response:
/// * https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.4
/// * https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.6
const MIN_MESSAGE_SIZE: usize = 1;
const MIN_NAME_SIZE: usize = 1;
const MIN_CHALLENGE_SIZE: usize = MS_CHAP_V2_ID_SIZE + MS_LENGTH_SIZE + VALUE_SIZE_SIZE
    + CHALLENGE_SIZE + MIN_NAME_SIZE;
const MIN_SUCCESS_REQUEST_SIZE: usize = MS_CHAP_V2_ID_SIZE + MS_LENGTH_SIZE
    + SUCCESS_REQUEST_AUTH_STRING_PREFIX.len() + SUCCESS_REQUEST_AUTH_STRING_SIZE;


#[derive(Clone)]
pub(crate) enum DecodeError {
    /// Challenge packet decode failure
    Challenge(String),
    /// Success request packet decode failure
    SuccessRequest(String),
    /// Other failures
    Other(String),
}

impl Display for DecodeError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "MS-CHAPv2 decode error: ")?;
        match self {
            DecodeError::Challenge(x) => write!(f, "Challenge: {}", x),
            DecodeError::SuccessRequest(x) => write!(f, "Success request: {}", x),
            DecodeError::Other(x) => write!(f, "{}", x),
        }
    }
}

/// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2
pub(crate) enum Message {
    /// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.1
    Challenge(Challenge),
    /// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.3
    SuccessRequest(SuccessRequest),
}

/// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.1
pub(crate) struct Challenge {
    /// The MS-CHAPv2-ID field is one octet and aids in matching MSCHAP-v2
    /// responses with requests. Typically, the MS-CHAPv2-ID field is the
    /// same as the Identifier field.
    pub ms_chap_v2_id: u8,
    /// The Challenge field is 16 octets.  The most significant octet is
    /// transmitted first.  The Challenge MUST be changed each time a
    /// Challenge is sent.
    pub challenge: [u8; CHALLENGE_SIZE],
    /// The Name field is one or more octets representing the identification
    /// of the system transmitting the packet.  There are no limitations on
    /// the content of this field.  The Name should not be NUL or CR/LF
    /// terminated.  The size of the Name field is equal to Length - Value-
    /// Size - 10.
    #[allow(unused)]
    pub name: Bytes,
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-4
/// https://datatracker.ietf.org/doc/html/rfc1994#section-4.1
pub(crate) struct Response {
    /// The MS-CHAPv2-ID field is one octet and aids in matching MSCHAP-v2
    /// responses with requests. Typically, the MS-CHAPv2-ID field is the
    /// same as the Identifier field.
    pub ms_chap_v2_id: u8,
    /// The Peer-Challenge field is a 16-octet random number.  As the name
    /// implies, it is generated by the peer and is used in the calculation
    /// of the NT-Response field.
    pub peer_challenge: [u8; CHALLENGE_SIZE],
    /// The NT-Response field is an encoded function of the password, the
    /// user name, the contents of the Peer-Challenge field and the received
    /// challenge as output by the routine GenerateNTResponse() (see section
    /// 8.1, below).  The Windows NT password is a string of 0 to
    /// (theoretically) 256 case-sensitive Unicode [8] characters.  Current
    /// versions of Windows NT limit passwords to 14 characters, mainly for
    /// compatibility reasons; this may change in the future.  When computing
    /// the NT-Response field contents, only the user name is used, without
    /// any associated Windows NT domain name.  This is true regardless of
    /// whether a Windows NT domain name is present in the Name field (see
    /// below).
    pub nt_response: [u8; RESPONSE_NT_RESPONSE_SIZE],
    /// The Name field is one or more octets representing the
    /// identification of the system transmitting the packet.  There are
    /// no limitations on the content of this field.  For example, it MAY
    /// contain ASCII character strings or globally unique identifiers in
    /// ASN.1 syntax.  The Name should not be NUL or CR/LF terminated.
    /// The size is determined from the Length field.
    pub name: String,
}

/// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.3
pub(crate) struct SuccessRequest {
    /// The MS-CHAPv2-ID field is one octet and aids in matching MSCHAP-v2
    /// responses with requests. Typically, the MS-CHAPv2-ID field is the
    /// same as the Identifier field.
    #[allow(unused)]
    pub ms_chap_v2_id: u8,
    /// The <auth_string> quantity is a 20 octet number encoded in ASCII as
    /// 40 hexadecimal digits.  The hexadecimal digits A-F (if present) MUST
    /// be uppercase.  This number is derived from the challenge from the
    /// Challenge packet, the Peer-Challenge and NT-Response fields from the
    /// Response packet, and the peer password as output by the routine
    /// GenerateAuthenticatorResponse() defined in [RFC2759], Section 8.7.
    /// The authenticating peer MUST verify the authenticator response when a
    /// Success packet is received.  The method for verifying the
    /// authenticator is described in [RFC2759], section 8.8.  If the
    /// authenticator response is either missing or incorrect, the peer MUST
    /// end the session without sending a response.
    pub auth_string: [u8; SUCCESS_REQUEST_AUTH_STRING_SIZE],
    /// The <message> quantity is human-readable text in the appropriate
    /// charset and language [RFC2484].
    #[allow(unused)]
    pub message: Bytes,
}

/// https://datatracker.ietf.org/doc/html/draft-kamath-pppext-eap-mschapv2-02#section-2.4
pub(crate) struct SuccessResponse;


impl Challenge {
    pub fn generate_response(&self, user_name: &str, password: &str) -> Response {
        let peer_challenge = ring::rand::generate(&ring::rand::SystemRandom::new()).unwrap().expose();
        let nt_response = generate_nt_response(&self.challenge, &peer_challenge, user_name, password);

        Response {
            ms_chap_v2_id: self.ms_chap_v2_id,
            peer_challenge,
            nt_response,
            name: user_name.to_string(),
        }
    }
}

impl Response {
    pub fn encode(&self) -> Vec<u8> {
        let total_length = OP_CODE_SIZE + MS_CHAP_V2_ID_SIZE + MS_LENGTH_SIZE + VALUE_SIZE_SIZE
            + RESPONSE_VALUE_SIZE + self.name.len();

        let mut out: Vec<u8> = Vec::with_capacity(total_length);
        out.push(OP_CODE_RESPONSE);
        out.push(self.ms_chap_v2_id);
        out.extend_from_slice(&(total_length as u16).to_be_bytes());
        out.push(RESPONSE_VALUE_SIZE as u8);
        out.extend_from_slice(&self.peer_challenge);
        out.extend_from_slice(&[0; RESPONSE_RESERVED_SIZE]);
        out.extend_from_slice(&self.nt_response);
        out.extend_from_slice(&[0; RESPONSE_FLAGS_SIZE]);
        out.extend_from_slice(self.name.as_bytes());

        out
    }
}

impl SuccessResponse {
    pub fn encode() -> Vec<u8> {
        Vec::from([OP_CODE_SUCCESS])
    }
}

/// The common EAP header fields are expected to be already cut from `data`
pub(crate) fn decode_message(eap_code: eap::Code, mut data: Bytes) -> Result<Message, DecodeError> {
    let orig_len = data.len();
    if data.len() < MIN_MESSAGE_SIZE {
        return Err(DecodeError::Other(format!("Shorter than minimum message size: {}", orig_len)));
    }

    match (eap_code, data.get_u8()) {
        (eap::CODE_REQUEST, OP_CODE_CHALLENGE) => decode_challenge_payload(data),
        (eap::CODE_REQUEST, OP_CODE_SUCCESS) => decode_success_request_payload(data),
        (eap, ms) => Err(DecodeError::Other(
            format!("Unexpected message: eap_code={}, ms_code={}", eap, ms)
        )),
    }
}

fn decode_challenge_payload(mut data: Bytes) -> Result<Message, DecodeError> {
    let orig_len = data.len();
    if orig_len < MIN_CHALLENGE_SIZE {
        return Err(DecodeError::Challenge(format!("Shorter than minimum message size: {}", orig_len)));
    }

    let ms_chap_v2_id = data.get_u8();
    let ms_length = data.get_u16() as usize;
    // The MS-Length field is two octets and MUST be set to the value of the Length field minus 5
    if ms_length != orig_len + OP_CODE_SIZE {
        return Err(DecodeError::Challenge(format!("Unexpected MS-Length value: {}", ms_length)));
    }

    let value_size = data.get_u8() as usize;
    if value_size != CHALLENGE_SIZE {
        return Err(DecodeError::Challenge(format!("Unexpected Value-Size value: {}", value_size)));
    }

    Ok(Message::Challenge(Challenge {
        ms_chap_v2_id,
        challenge: data.split_to(value_size).as_ref().try_into().unwrap(),
        name: data,
    }))
}

fn decode_success_request_payload(mut data: Bytes) -> Result<Message, DecodeError> {
    let orig_len = data.len();
    if orig_len < MIN_SUCCESS_REQUEST_SIZE {
        return Err(DecodeError::SuccessRequest(format!("Shorter than minimum message size: {}", orig_len)));
    }

    let ms_chap_v2_id = data.get_u8();
    let ms_length = data.get_u16() as usize;
    // The MS-Length field is two octets and MUST be set to the value of the Length field minus 5
    if ms_length != orig_len + OP_CODE_SIZE {
        return Err(DecodeError::SuccessRequest(format!("Unexpected MS-Length value: {}", ms_length)));
    }

    let auth_string = {
        let auth_string = data.split_to(
            SUCCESS_REQUEST_AUTH_STRING_PREFIX.len() + SUCCESS_REQUEST_AUTH_STRING_SIZE
        );
        match auth_string.strip_prefix(SUCCESS_REQUEST_AUTH_STRING_PREFIX.as_bytes()) {
            None => return Err(DecodeError::SuccessRequest(
                format!("Unexpected auth_string value: {}", utils::hex_dump(&auth_string))
            )),
            Some(x) => x.try_into().unwrap(),
        }
    };

    Ok(Message::SuccessRequest(SuccessRequest {
        ms_chap_v2_id,
        auth_string,
        message: data,
    }))
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.1
fn generate_nt_response(
    auth_challenge: &[u8; CHALLENGE_SIZE],
    peer_challenge: &[u8; CHALLENGE_SIZE],
    user_name: &str,
    password: &str,
) -> [u8; RESPONSE_NT_RESPONSE_SIZE] {
    let challenge = challenge_hash(peer_challenge, auth_challenge, user_name);
    let password_hash = nt_password_hash(password.encode_utf16());
    challenge_response(&challenge, &password_hash)
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.2
fn challenge_hash(
    peer_challenge: &[u8; CHALLENGE_SIZE],
    authenticator_challenge: &[u8; CHALLENGE_SIZE],
    user_name: &str,
) -> [u8; CHALLENGE_HASH_SIZE] {
    use crypto::digest::Digest;

    let mut hasher = Sha1::new();
    hasher.input(peer_challenge);
    hasher.input(authenticator_challenge);
    hasher.input(user_name.as_bytes());

    let mut out = [0; utils::SHA1_DIGEST_SIZE];
    hasher.result(&mut out);
    out[..CHALLENGE_HASH_SIZE].try_into().unwrap()
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.3
fn nt_password_hash(password: EncodeUtf16) -> [u8; PASSWORD_HASH_SIZE] {
    use md4::Digest;

    let mut hasher = md4::Md4::new();
    let size_hint = password.size_hint();
    hasher.update(password.fold(
        Vec::with_capacity(size_hint.1.unwrap_or(size_hint.0)),
        |mut out, c| { out.extend_from_slice(&c.to_le_bytes()); out }
    ));

    let mut hash = [0; PASSWORD_HASH_SIZE];
    hash.copy_from_slice(&hasher.finalize());
    hash
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.4
fn hash_nt_password_hash(password_hash: &[u8; PASSWORD_HASH_SIZE]) -> [u8; PASSWORD_HASH_SIZE] {
    use md4::Digest;

    let mut hasher = md4::Md4::new();
    hasher.update(password_hash);

    let mut hash = [0; PASSWORD_HASH_SIZE];
    hash.copy_from_slice(&hasher.finalize());
    hash
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.5
fn challenge_response(
    challenge: &[u8; CHALLENGE_HASH_SIZE],
    password_hash: &[u8; PASSWORD_HASH_SIZE],
) -> [u8; RESPONSE_NT_RESPONSE_SIZE] {
    let mut padded_hash = [0; 21];
    padded_hash[..password_hash.len()].copy_from_slice(password_hash);

    let mut response = [0; RESPONSE_NT_RESPONSE_SIZE];
    for i in 0..3 {
        response[i * 8..(i + 1) * 8].copy_from_slice(
            &des_encrypt(challenge, (&padded_hash[i * 7..(i + 1) * 7]).try_into().unwrap())
        );
    }

    response
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.6
fn des_encrypt(clear: &[u8; 8], key: &[u8; 7]) -> [u8; 8] {
    use des::cipher::BlockEncrypt;
    use des::cipher::crypto_common::KeyInit;

    let parity_key = des_parity_key(key);
    let encryptor = des::Des::new_from_slice(&parity_key).unwrap();
    let mut block = des::cipher::generic_array::GenericArray::clone_from_slice(clear);
    encryptor.encrypt_block(&mut block);
    block.try_into().unwrap()
}

fn des_parity_key(key_in: &[u8; 7]) -> [u8; 8] {
    let mut c_next = 0;
    let mut out = [0; 8];

    for (i, x) in key_in.iter().cloned().enumerate() {
        out[i] = ((x >> i) | c_next | 1) as u8;
        c_next = x << (7 - i);
    }

    out[7] = c_next | 1;

    out
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.7
fn generate_authenticator_response(
    password: &str,
    nt_response: &[u8; RESPONSE_NT_RESPONSE_SIZE],
    peer_challenge: &[u8; CHALLENGE_SIZE],
    authenticator_challenge: &[u8; CHALLENGE_SIZE],
    user_name: &str,
) -> [u8; SUCCESS_REQUEST_AUTH_STRING_SIZE] {
    use crypto::digest::Digest;

    const MAGIC_1: [u8; 39] = [
        0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65, 0x72, 0x76,
        0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6C, 0x69, 0x65,
        0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67,
        0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74,
    ];

    const MAGIC_2: [u8; 41] = [
        0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B,
        0x65, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6D, 0x6F,
        0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E,
        0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
        0x6E,
    ];

    let mut digest = [0; utils::SHA1_DIGEST_SIZE];

    let password_hash_hash = hash_nt_password_hash(&nt_password_hash(password.encode_utf16()));

    let mut hasher = Sha1::new();
    hasher.input(&password_hash_hash);
    hasher.input(nt_response);
    hasher.input(&MAGIC_1);
    hasher.result(&mut digest);

    let challenge = challenge_hash(peer_challenge, authenticator_challenge, user_name);

    let mut hasher = Sha1::new();
    hasher.input(&digest);
    hasher.input(&challenge);
    hasher.input(&MAGIC_2);
    hasher.result(&mut digest);

    utils::hex_dump_uppercase(&digest).as_bytes().try_into().unwrap()
}

/// https://datatracker.ietf.org/doc/html/rfc2759#section-8.8
pub(crate) fn check_authenticator_response(
    password: &str,
    nt_response: &[u8; RESPONSE_NT_RESPONSE_SIZE],
    peer_challenge: &[u8; CHALLENGE_SIZE],
    authenticator_challenge: &[u8; CHALLENGE_SIZE],
    user_name: &str,
    received_response: &[u8; SUCCESS_REQUEST_AUTH_STRING_SIZE],
) -> bool {
    let my_response = generate_authenticator_response(
        password, nt_response, peer_challenge, authenticator_challenge, user_name
    );
    *received_response == my_response
}
