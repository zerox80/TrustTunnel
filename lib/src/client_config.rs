use crate::{authentication::registry_based, settings::TlsHostsSettings, utils::ToTomlComment};
#[cfg(feature = "rt_doc")]
use macros::{Getter, RuntimeDoc};
use once_cell::sync::Lazy;
use std::net::SocketAddr;
use toml_edit::{value, Document};

pub fn build(
    client: &String,
    addresses: Vec<SocketAddr>,
    username: &Vec<registry_based::Client>,
    hostsettings: &TlsHostsSettings,
) -> ClientConfig {
    let user = username
        .iter()
        .find(|x| x.username == *client)
        .expect("There is no user config for specified username");

    let host = hostsettings
        .main_hosts
        .first()
        .expect("Can't find main host inside hosts config");

    ClientConfig {
        hostname: host.hostname.clone(),
        addresses: addresses,
        has_ipv6: true, // Hardcoded to true, client could change this himself
        username: user.username.clone(),
        password: user.password.clone(),
        skip_verification: false,
        certificate: std::fs::read_to_string(&host.cert_chain_path)
            .expect("Failed to load certificate"),
        upstream_protocol: "http2".into(),
        upstream_fallback_protocol: "".into(),
        anti_dpi: false,
    }
}

#[cfg_attr(feature = "rt_doc", derive(Getter, RuntimeDoc))]
pub struct ClientConfig {
    /// Endpoint host name, used for TLS session establishment
    hostname: String,
    /// Endpoint addresses.
    addresses: Vec<SocketAddr>,
    /// Whether IPv6 traffic can be routed through the endpoint
    has_ipv6: bool,
    /// Username for authorization
    username: String,
    /// Password for authorization
    password: String,
    /// Skip the endpoint certificate verification?
    /// That is, any certificate is accepted with this one set to true.
    skip_verification: bool,
    /// Endpoint certificate in PEM format.
    /// If not specified, the endpoint certificate is verified using the system storage.
    certificate: String,
    /// Protocol to be used to communicate with the endpoint [http2, http3]
    upstream_protocol: String,
    /// Fallback protocol to be used in case the main one fails [<none>, http2, http3]
    upstream_fallback_protocol: String,
    /// Is anti-DPI measures should be enabled
    anti_dpi: bool,
}

impl ClientConfig {
    pub fn compose_toml(&self) -> String {
        let mut doc: Document = TEMPLATE.parse().unwrap();
        doc["hostname"] = value(&self.hostname);
        let vec = toml_edit::Array::from_iter(self.addresses.iter().map(|x| x.to_string()));
        doc["addresses"] = value(vec);
        doc["has_ipv6"] = value(self.has_ipv6);
        doc["username"] = value(&self.username);
        doc["password"] = value(&self.password);
        doc["skip_verification"] = value(self.skip_verification);
        doc["certificate"] = value(&self.certificate);
        doc["upstream_protocol"] = value(&self.upstream_protocol);
        doc["upstream_fallback_protocol"] = value(&self.upstream_fallback_protocol);
        doc["anti_dpi"] = value(self.anti_dpi);
        doc.to_string()
    }
}

static TEMPLATE: Lazy<String> = Lazy::new(|| {
    format!(
        r#"
# This file was automatically generated by endpoint and could be used in vpn client.

{}
hostname = ""

{}
addresses = []

{}
has_ipv6 = true

{}
username = ""

{}
password = ""

{}
skip_verification = false

{}
certificate = ""

{}
upstream_protocol = ""

{}
upstream_fallback_protocol = ""

{}
anti_dpi = false
"#,
        ClientConfig::doc_hostname().to_toml_comment(),
        ClientConfig::doc_addresses().to_toml_comment(),
        ClientConfig::doc_has_ipv6().to_toml_comment(),
        ClientConfig::doc_username().to_toml_comment(),
        ClientConfig::doc_password().to_toml_comment(),
        ClientConfig::doc_skip_verification().to_toml_comment(),
        ClientConfig::doc_certificate().to_toml_comment(),
        ClientConfig::doc_upstream_protocol().to_toml_comment(),
        ClientConfig::doc_upstream_fallback_protocol().to_toml_comment(),
        ClientConfig::doc_anti_dpi().to_toml_comment(),
    )
});
